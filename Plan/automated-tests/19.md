# TASK-19: Add tests for `BullMQQueueView`

**Section**: 3. Unit Tests for Untested Components (Phase 2A)
**Subsection**: 3.4 File System & Queue Components
**Task ID**: TASK-19

## Description

This task creates comprehensive unit tests for the `BullMQQueueView` component. This component displays Bull MQ queue information with automatic polling (every 5 seconds) and manual refresh capability.

The tests will verify:
- Initial load calls `listQueues` API
- Queue cards are rendered with correct information
- Refresh button triggers manual reload
- Polling works correctly (5-second interval)
- Polling stops on unmount
- Error and empty states are displayed correctly
- Status colors for waiting/active/failed counts follow thresholds
- Integration with MSW for API mocking

This component requires special attention to polling behavior and timer management.

## Current State

- `BullMQQueueView` component exists at `src/components/BullMQQueueView.tsx`
- Component uses `listQueues` from `src/api/queues`
- Component implements polling with 5-second interval
- Component has manual refresh button
- Component displays queue cards with status information
- Component uses status color thresholds (0, <5, <10, >=10)
- No tests currently exist for this component
- MSW should be set up (from TASK-3) for API mocking

**Reference Implementation**: 
- `src/components/BullMQQueueView.tsx` (full file)
- `src/api/queues.ts` for API client structure
- Vitest fake timers documentation

**Important**: This task should be executed after TASK-1, TASK-2, TASK-3, TASK-4 are complete.

## Checklist

### Preparation and Setup

- [ ] Review `BullMQQueueView.tsx` component code
- [ ] Review polling implementation (setInterval, cleanup)
- [ ] Review `src/api/queues.ts` to understand `listQueues` API
- [ ] Review MSW handlers from TASK-3 for queues endpoints
- [ ] Review Vitest fake timers documentation
- [ ] Understand status color thresholds

### Implementation Steps

- [ ] Step 1: Create test file
  - [ ] Create `src/components/__tests__/BullMQQueueView.test.tsx`
  - [ ] Import necessary testing utilities and components
  - [ ] Set up MSW handlers for queues API

- [ ] Step 2: Set up test structure
  - [ ] Create describe block for BullMQQueueView
  - [ ] Set up MSW handler for `GET /agents/queues`
  - [ ] Create mock queue data
  - [ ] Configure fake timers using `vi.useFakeTimers()`

- [ ] Step 3: Write tests for initial load
  - [ ] Test: Component calls `listQueues` on mount
  - [ ] Test: Queue cards are rendered
  - [ ] Test: Queue information is displayed correctly (name, counts, agents)
  - [ ] Test: LoadingSpinner shown during load, then hidden
  - [ ] Test: Header with "Bull MQ Queues" title is displayed
  - [ ] Test: Refresh button is rendered

- [ ] Step 4: Write tests for refresh button
  - [ ] Test: Clicking refresh button calls `listQueues`
  - [ ] Test: Refresh button triggers queue reload
  - [ ] Test: UI updates after refresh
  - [ ] Test: Loading state during refresh (if applicable)

- [ ] Step 5: Write tests for polling behavior
  - [ ] Test: After initial load, polling interval is scheduled (5 seconds)
  - [ ] Test: Polling calls `listQueues` at intervals
  - [ ] Test: Polling updates queues when data changes
  - [ ] Test: Polling stops on component unmount
  - [ ] Test: Polling doesn't start if still loading

- [ ] Step 6: Write tests for status colors
  - [ ] Test: Count 0 shows gray color
  - [ ] Test: Count < 5 shows blue color
  - [ ] Test: Count < 10 shows orange color
  - [ ] Test: Count >= 10 shows red color
  - [ ] Test: Colors apply to waiting, active, and failed counts
  - [ ] Test: Status colors are displayed correctly in UI

- [ ] Step 7: Write tests for error handling
  - [ ] Test: Network error displays error message
  - [ ] Test: ErrorMessage component receives error message
  - [ ] Test: Queue cards not rendered when error occurs
  - [ ] Test: Polling continues even after error (if applicable)

- [ ] Step 8: Write tests for empty state
  - [ ] Test: "No queues found" message shown when queue list is empty
  - [ ] Test: Empty state only shown when not loading and no error
  - [ ] Test: Queue cards not rendered when empty

- [ ] Step 9: Write tests for queue card rendering
  - [ ] Test: Queue name is displayed
  - [ ] Test: Queue counts (waiting, active, completed, failed, delayed) are displayed
  - [ ] Test: Agents list is displayed when available
  - [ ] Test: Active jobs indicator is shown correctly
  - [ ] Test: Multiple queues are rendered correctly

### Specific Requirements

- [ ] Requirement 1: API integration tested
  - `listQueues` API call is tested
  - MSW handlers work correctly
  - Error responses are handled

- [ ] Requirement 2: Polling behavior tested
  - Polling interval is correct (5 seconds)
  - Polling updates queues when data changes
  - Polling cleanup works on unmount

- [ ] Requirement 3: Refresh functionality tested
  - Refresh button works
  - Manual refresh triggers API reload

- [ ] Requirement 4: Status colors tested
  - Status colors follow thresholds correctly
  - Colors apply to all count types
  - Colors are displayed in UI

### Error Handling and Edge Cases

- [ ] Handle case: API returns empty array
  - Empty state is displayed
  - No errors thrown

- [ ] Handle case: API call fails
  - Error message is displayed
  - Component doesn't crash
  - Polling may continue (verify behavior)

- [ ] Handle case: Polling request fails
  - Error is handled gracefully
  - Polling continues (or stops, verify behavior)
  - User experience is not disrupted

- [ ] Handle case: Component unmounts during polling
  - Polling interval is cleared
  - No memory leaks
  - No errors in console

- [ ] Handle case: Rapid refresh clicks
  - Component handles gracefully
  - No duplicate API calls (or handles them correctly)

### Testing

- [ ] Write all test cases for BullMQQueueView
- [ ] Use MSW to mock API responses
- [ ] Use fake timers (`vi.useFakeTimers()`) for polling tests
- [ ] Use `vi.advanceTimersByTime()` to advance time
- [ ] Use userEvent for button clicks
- [ ] Run tests: `npm test -- BullMQQueueView.test.tsx`
- [ ] Verify all tests pass
- [ ] Run full test suite: `npm test`
- [ ] Run type checking: `npm run type-check`
- [ ] Run linting: `npm run lint`
- [ ] Check test coverage

### Documentation

- [ ] Add JSDoc comments to test file if needed
- [ ] Document fake timer usage patterns
- [ ] Document polling test patterns
- [ ] Add comments for complex test scenarios

### Verification

- [ ] Verify all BullMQQueueView functionality is tested
- [ ] Verify tests pass
- [ ] Verify no regressions in other tests
- [ ] Verify test coverage meets requirements
- [ ] Verify fake timers are properly cleaned up

## Notes

- This task is part of Section 3: Unit Tests for Untested Components (Phase 2A)
- **Execution Timing**: Execute after TASK-1, TASK-2, TASK-3, TASK-4 are complete
- **Dependencies**: 
  - TASK-1: Confirm local setup
  - TASK-2: Review existing test utilities
  - TASK-3: Introduce MSW (required for API mocking)
  - TASK-4: Configure coverage thresholds
- **Important Considerations**: 
  - Use fake timers (`vi.useFakeTimers()`) to control polling intervals
  - Use `vi.advanceTimersByTime()` to advance time in tests
  - Clean up fake timers after each test (`vi.useRealTimers()`)
  - Test polling cleanup on unmount
  - Test status color thresholds carefully
  - Use MSW handlers from TASK-3 for API mocking
- **Task Independence**: Can be completed independently after prerequisites
- **Current State**: BullMQQueueView component exists but has no tests

## Related Tasks

- Previous: TASK-18 (Add tests for WorkingDirectoryBrowser)
- Next: TASK-20 (Add tests for src/api/queues.ts)
- Dependencies:
  - TASK-1: Confirm local setup
  - TASK-2: Review existing test utilities
  - TASK-3: Introduce MSW (required)
  - TASK-4: Configure coverage thresholds
- Related: TASK-20 (queues API client is used by this component)

## Definition of Done

### Task Type: TESTING TASK

**Description**: This task involves writing comprehensive unit tests for the BullMQQueueView component, including polling behavior.

**Definition of Done**: 

1. **Test file created**:
   - `src/components/__tests__/BullMQQueueView.test.tsx` exists
   - File follows project conventions and patterns

2. **Tests written**:
   - Initial load tested
   - Refresh button tested
   - Polling behavior tested (interval, updates, cleanup)
   - Status colors tested
   - Error handling tested
   - Empty state tested
   - Queue card rendering tested

3. **Tests pass**:
   - All BullMQQueueView tests pass
   - Full test suite passes: `npm test`
   - No test failures or errors
   - Fake timers are properly managed

4. **Coverage meets requirements**:
   - BullMQQueueView component has adequate test coverage
   - Coverage meets project thresholds (≥80% minimum)

5. **Code quality**:
   - Tests use semantic queries
   - Tests use MSW for API mocking
   - Tests use fake timers correctly
   - Tests are readable and maintainable
   - No linting errors
   - Type checking passes

6. **Code committed and pushed**:
   - Test file committed
   - Commit message: `test: add comprehensive tests for BullMQQueueView component with polling`
   - Code pushed to origin: `git push origin <branch-name>`

7. **User Story** (as a developer):
   - **As a** developer maintaining the BullMQQueueView component
   - **I want** comprehensive unit tests that verify API integration, polling behavior, status colors, and refresh functionality
   - **So that** I can confidently refactor and extend the component without breaking functionality

8. **Automated Tests**:
   - All BullMQQueueView tests written and passing
   - Test coverage for component meets requirements
   - Full test suite passes: `npm test` must complete successfully
   - Test verification: Run `npm test -- BullMQQueueView.test.tsx` and confirm all tests pass
   - Fake timers are properly cleaned up (no hanging tests)

**Acceptance Criteria**:
- ✅ `src/components/__tests__/BullMQQueueView.test.tsx` created with comprehensive tests
- ✅ All scenarios tested (load, refresh, polling, status colors, errors, empty)
- ✅ MSW used for API mocking
- ✅ Fake timers used correctly for polling tests
- ✅ All tests pass
- ✅ Test coverage meets requirements
- ✅ All changes committed and pushed to origin

**Tests are written, all tests pass, and test coverage meets project requirements**

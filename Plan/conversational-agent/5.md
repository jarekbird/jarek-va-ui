# Implement Agent Conversation API Client

## Scope
`jarek-va-ui`.

## Subtasks
- Create `src/api/agent-conversations.ts` with:
  - `listAgentConversations()`.
  - `getAgentConversation(id: string)`.
  - `createAgentConversation()` (POST).
- Wire these functions to `/agent-conversations/api/*` routes.
- Centralize base URL configuration (re-using API base logic from existing `api` modules where sensible).
- Add basic error handling and TypeScript typings.

## Desired Outcomes

### Primary Outcomes
1. **API Abstraction**: Clean, typed functions that abstract away HTTP details, making it easy for components to interact with the backend.

2. **Error Handling**: Consistent error handling across all API calls with proper error types and user-friendly messages.

3. **Type Safety**: Full TypeScript integration ensuring API responses match expected types.

4. **Reusability**: Centralized base URL and configuration logic that can be reused across API modules.

5. **Maintainability**: Clear separation of concerns with API logic isolated from UI components.

### Success Criteria
- All three API functions implemented and tested
- Proper error handling for network failures, 4xx, 5xx responses
- TypeScript types match backend contracts
- Base URL configurable via environment variables
- Error messages user-friendly and actionable
- Functions handle loading states appropriately

## User Stories

### As a Developer
- **Story 1**: I want typed API functions so that I can easily call backend endpoints with autocomplete and type checking.
- **Story 2**: I want consistent error handling so that I don't have to write error handling logic in every component.
- **Story 3**: I want configurable base URLs so that I can point to different environments (dev, staging, prod).

### As a User
- **Story 4**: I want clear error messages when API calls fail so that I understand what went wrong.

### As a QA Engineer
- **Story 5**: I want API functions to handle edge cases (network failures, timeouts) so that the app doesn't crash.

## Suggested Automated Tests

### Unit Tests
1. **API Function Tests**:
   ```typescript
   describe('agent-conversations API', () => {
     it('listAgentConversations calls correct endpoint', async () => {
       const mockFetch = jest.fn().mockResolvedValue({
         ok: true,
         json: async () => ({ conversations: [] })
       });
       global.fetch = mockFetch;
       
       await listAgentConversations();
       expect(mockFetch).toHaveBeenCalledWith(
         expect.stringContaining('/agent-conversations/api/list')
       );
     });
     
     it('getAgentConversation calls correct endpoint with ID', async () => {
       // Test detail endpoint
     });
     
     it('createAgentConversation POSTs with correct body', async () => {
       // Test creation endpoint
     });
   });
   ```

2. **Error Handling Tests**:
   ```typescript
   describe('Error Handling', () => {
     it('handles network errors', async () => {
       global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));
       await expect(listAgentConversations()).rejects.toThrow();
     });
     
     it('handles 404 errors', async () => {
       global.fetch = jest.fn().mockResolvedValue({
         ok: false,
         status: 404
       });
       // Verify error handling
     });
     
     it('handles 500 errors', async () => {
       // Test server error handling
     });
   });
   ```

3. **Type Safety Tests**:
   ```typescript
   describe('Type Safety', () => {
     it('returns typed AgentConversation[]', async () => {
       const conversations = await listAgentConversations();
       expect(conversations).toBeInstanceOf(Array);
       // TypeScript ensures type
     });
   });
   ```

### Integration Tests
4. **End-to-End API Tests**:
   ```typescript
   describe('API Integration', () => {
     it('creates, lists, and retrieves conversation', async () => {
       const created = await createAgentConversation();
       const list = await listAgentConversations();
       expect(list).toContainEqual(expect.objectContaining({ id: created.id }));
       
       const retrieved = await getAgentConversation(created.id);
       expect(retrieved).toEqual(created);
     });
   });
   ```

## Inherent Risks

### High Risk
1. **API Contract Mismatch**:
   - **Risk**: Frontend expects different structure than backend provides, causing runtime errors
   - **Mitigation**: Validate against actual API responses, use schema validation libraries, coordinate with backend team

2. **Error Handling Gaps**:
   - **Risk**: Unhandled error cases causing app crashes or poor UX
   - **Mitigation**: Comprehensive error handling, test all error paths, user-friendly error messages

### Medium Risk
3. **Base URL Misconfiguration**:
   - **Risk**: API calls go to wrong environment or fail due to incorrect base URL
   - **Mitigation**: Environment variable validation, clear documentation, default values for dev

4. **Network Timeout Issues**:
   - **Risk**: Long-running requests causing UI to hang
   - **Mitigation**: Implement timeouts, show loading states, provide cancel functionality

5. **Type-Response Mismatch**:
   - **Risk**: TypeScript types don't match actual API responses
   - **Mitigation**: Runtime validation, type guards, update types when API changes

### Low Risk
6. **Code Duplication**:
   - **Risk**: Duplicating base URL or error handling logic
   - **Mitigation**: Extract shared utilities, use existing patterns from other API modules

7. **Over-Engineering**:
   - **Risk**: Adding unnecessary complexity (caching, retries) before needed
   - **Mitigation**: Start simple, add complexity only when needed, follow YAGNI principle

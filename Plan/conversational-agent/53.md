# Step 53: Implement Text Message Sending

**Phase**: Phase 3 â€“ Frontend Integration (UI, Conversations, File Browser)

## Description

Implement initial plain text send for agent conversations:
- On text submit, call a new endpoint (or reuse existing pattern) to send a text message to the agent (plan-level; can be stubbed at first).
- Immediately append a local `AgentMessage` with role `'user'`, then wait for agent response through voice or text channel if needed.

## Detailed Desired Outcomes

### Message Sending Flow

**Text Input Handling:**
- User types message in input field
- User clicks Send or presses Enter
- Validate message (not empty, reasonable length)
- Create `AgentMessage` with:
  ```typescript
  {
    role: 'user',
    content: string,
    timestamp: string,
    source: 'text'
  }
  ```

**Optimistic UI:**
- Add message to local state immediately
- Show message in UI right away
- Don't wait for API response
- Update UI optimistically

**API Call:**
- Call API endpoint to send message to agent
- Endpoint: `POST /agent-conversations/api/{conversationId}/message` (to be created)
- Or use existing pattern if available
- Payload: `{ content: string }`
- Handle API errors gracefully

**Agent Response:**
- Wait for agent response
- Response might come via:
  - Voice channel (onMessage event)
  - Text channel (API response)
- Append agent response to conversation
- Update UI with response

### Error Handling

**Validation Errors:**
- Empty message: Show error, don't send
- Too long message: Show error, don't send
- Invalid characters: Show error, don't send

**API Errors:**
- Network errors: Show error, allow retry
- Server errors: Show error, allow retry
- Don't remove optimistic message on error (or show error state)

## User Stories

**As a user**, I want:
- Easy way to send text messages
- Fast message sending (optimistic UI)
- Clear feedback if sending fails
- Agent responses to appear quickly

**As a developer**, I want:
- Simple message sending flow
- Easy to extend with more features
- Good error handling

**As a system**, I want:
- Reliable message delivery
- Proper error handling
- Good user experience

## Suggested Automated Tests

### Message Sending Tests

```typescript
describe('Text Message Sending', () => {
  it('should send message on submit', async () => {
    const sendMessageSpy = jest.spyOn(api, 'sendAgentMessage');
    
    render(<AgentConversationDetails conversation={mockConversation} />);

    const input = screen.getByPlaceholderText(/Type a message/i);
    const sendButton = screen.getByRole('button', { name: /Send/i });

    fireEvent.change(input, { target: { value: 'Test message' } });
    fireEvent.click(sendButton);

    await waitFor(() => {
      expect(sendMessageSpy).toHaveBeenCalledWith('conv-123', 'Test message');
    });
  });

  it('should add message optimistically', () => {
    render(<AgentConversationDetails conversation={mockConversation} />);

    const input = screen.getByPlaceholderText(/Type a message/i);
    const sendButton = screen.getByRole('button', { name: /Send/i });

    fireEvent.change(input, { target: { value: 'Test' } });
    fireEvent.click(sendButton);

    // Message should appear immediately
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('should validate empty message', () => {
    render(<AgentConversationDetails conversation={mockConversation} />);

    const sendButton = screen.getByRole('button', { name: /Send/i });
    fireEvent.click(sendButton);

    // Should show validation error
    expect(screen.getByText(/Message cannot be empty/i)).toBeInTheDocument();
  });

  it('should handle API errors', async () => {
    jest.spyOn(api, 'sendAgentMessage').mockRejectedValue(
      new Error('Network error')
    );

    render(<AgentConversationDetails conversation={mockConversation} />);

    const input = screen.getByPlaceholderText(/Type a message/i);
    const sendButton = screen.getByRole('button', { name: /Send/i });

    fireEvent.change(input, { target: { value: 'Test' } });
    fireEvent.click(sendButton);

    await waitFor(() => {
      expect(screen.getByText(/Failed to send/i)).toBeInTheDocument();
    });
  });
});
```

## Risks

### Low Risk
- **API endpoint missing**: Endpoint might not exist yet
  - **Mitigation**: Stub API call, implement endpoint later
  - **Detection**: API errors, integration tests

- **Validation issues**: Messages might not be validated correctly
  - **Mitigation**: Comprehensive validation, test edge cases
  - **Detection**: Testing, user feedback

### Medium Risk
- **Optimistic UI issues**: Optimistic message might cause confusion
  - **Mitigation**: Show sending state, handle errors clearly
  - **Detection**: User testing, feedback

- **Response handling**: Agent response might not be handled correctly
  - **Mitigation**: Test response handling, handle both voice and text
  - **Detection**: Integration tests, user reports

### High Risk
- **None identified** - Message sending with low risk

## Implementation Notes

- Handle text input submission
- Create user message immediately (optimistic UI)
- Call API to send message to agent
- Wait for agent response
- Append agent response when received
- Handle errors appropriately
- Can be stubbed initially if backend not ready
- Add message validation
- Show sending state
- Test with real API when available

# Implement Callback Queue Service

## Scope
`elevenlabs-agent`.

## Subtasks
- Implement `services/callback-queue.ts`:
  - Functions to create, update, and read `cursor_task:{taskId}` entries.
  - Store `conversationId`, `sessionPayload`, `wsUrl`, `pending`, `createdAt`, `toolName`, and `toolArgs`.
- Add a TTL (~24h) for callback tasks.
- Add tests to validate race-condition safe behavior (out-of-order completion).

## Desired Outcomes

### Primary Outcomes
1. **Callback Task Tracking**: Reliable storage of cursor task metadata linked to agent sessions, enabling callbacks to push completion messages to the correct agent.

2. **Race Condition Safety**: Deterministic mapping of task IDs to sessions, preventing race conditions when tasks complete out of order.

3. **Long-Running Task Support**: 24-hour TTL allows slow cursor tasks to complete without losing callback context.

4. **Task State Management**: Track task state (pending/completed) for monitoring and debugging.

### Success Criteria
- Tasks can be created, retrieved, and updated
- TTL of 24 hours enforced
- All required fields stored correctly
- Race condition tests pass
- Out-of-order completion handled correctly
- Missing tasks handled gracefully
- Task state tracked accurately

## User Stories

### As a Developer
- **Story 1**: I want a callback queue so that cursor task completions can be routed to the correct agent session.
- **Story 2**: I want race condition safety so that out-of-order task completions don't cause issues.

### As a System Administrator
- **Story 3**: I want task state tracking so that I can monitor cursor task execution.

## Suggested Automated Tests

### Unit Tests
1. **Task Storage Tests**:
   ```typescript
   describe('Callback Queue', () => {
     it('creates callback task with all fields', async () => {
       const task = {
         conversationId: 'conv-123',
         sessionPayload: {...},
         wsUrl: 'wss://...',
         pending: true,
         createdAt: new Date().toISOString(),
         toolName: 'write_code',
         toolArgs: {...}
       };
       await callbackQueue.create('task-123', task);
       const retrieved = await callbackQueue.get('task-123');
       expect(retrieved).toMatchObject(task);
     });
     
     it('updates task state', async () => {
       await callbackQueue.create('task-123', task);
       await callbackQueue.update('task-123', { pending: false, completedAt: new Date() });
       const updated = await callbackQueue.get('task-123');
       expect(updated.pending).toBe(false);
     });
   });
   ```

2. **Race Condition Tests**:
   ```typescript
   describe('Race Condition Safety', () => {
     it('handles out-of-order task completion', async () => {
       // Create tasks
       await callbackQueue.create('task-1', task1);
       await callbackQueue.create('task-2', task2);
       
       // Complete tasks out of order
       await callbackQueue.update('task-2', { pending: false });
       await callbackQueue.update('task-1', { pending: false });
       
       // Verify both tasks completed correctly
       expect(await callbackQueue.get('task-1')).toHaveProperty('pending', false);
       expect(await callbackQueue.get('task-2')).toHaveProperty('pending', false);
     });
     
     it('maintains correct session mapping during concurrent updates', async () => {
       // Test concurrent updates don't corrupt data
     });
   });
   ```

3. **TTL Tests**:
   ```typescript
   describe('TTL Behavior', () => {
     it('sets 24-hour TTL', async () => {
       await callbackQueue.create('task-123', task);
       const ttl = await redis.ttl('cursor_task:task-123');
       expect(ttl).toBeCloseTo(86400, -3); // ~24 hours
     });
   });
   ```

## Inherent Risks

### High Risk
1. **Race Conditions**:
   - **Risk**: Concurrent task completions causing incorrect session mapping
   - **Mitigation**: Atomic Redis operations, proper key structure, comprehensive race condition tests

2. **Task Data Loss**:
   - **Risk**: Tasks not stored correctly, causing callback failures
   - **Mitigation**: Validation, error handling, monitoring, tests

### Medium Risk
3. **TTL Too Short**:
   - **Risk**: Slow tasks expire before completion, losing callback context
   - **Mitigation**: 24-hour TTL, monitor task durations, adjust if needed

4. **Memory Usage**:
   - **Risk**: Many pending tasks consuming Redis memory
   - **Mitigation**: Monitor memory, cleanup completed tasks, TTL enforcement

### Low Risk
5. **Key Collisions**:
   - **Risk**: Task ID collisions causing data corruption
   - **Mitigation**: Unique task ID generation, validation, error handling

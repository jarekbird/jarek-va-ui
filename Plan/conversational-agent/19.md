# Implement Callback Route for Cursor Completion

## Scope
`elevenlabs-agent`.

## Subtasks
- Implement `POST /callback`:
  - Validate incoming `requestId` and result payload.
  - Look up `cursor_task:{taskId}` in Redis.
  - If missing, log and return success (idempotent behavior).
  - Retrieve `sessionPayload` and `wsUrl` from the stored callback task.
  - Construct MVP `input_text` message JSON summarizing the task result.
  - Push the message to ElevenLabs via the stored endpoint (WebSocket or HTTP as required).
  - Mark task as completed in Redis (update `pending` flag and `completedAt`).

## Desired Outcomes

### Primary Outcomes
1. **Callback Handler**: Reliable endpoint that receives cursor task completions and pushes updates to the correct agent.

2. **Message Delivery**: Completion messages successfully delivered to ElevenLabs agent, enabling natural conversation flow.

3. **Idempotency**: Duplicate callbacks handled gracefully without errors.

4. **Task State Tracking**: Tasks marked as completed for monitoring and debugging.

### Success Criteria
- Callbacks received and processed correctly
- Messages pushed to ElevenLabs successfully
- Missing tasks handled idempotently
- Task state updated in Redis
- Error handling for push failures
- Clear logging for debugging
- Tests cover all scenarios

## User Stories

### As a User
- **Story 1**: I want to receive completion notifications from cursor tasks so that I know when work is done.

### As a Developer
- **Story 2**: I want reliable callbacks so that task completions are always delivered to agents.

### As a System Administrator
- **Story 3**: I want task state tracking so that I can monitor cursor task execution.

## Suggested Automated Tests

### Unit Tests
1. **Callback Processing Tests**:
   ```typescript
   describe('POST /callback', () => {
     it('processes callback and pushes to agent', async () => {
       // Setup: create callback task in Redis
       await callbackQueue.create('task-123', {
         conversationId: 'conv-123',
         sessionPayload: {...},
         wsUrl: 'wss://...'
       });
       
       const callbackPayload = {
         requestId: 'task-123',
         success: true,
         output: 'Task completed successfully'
       };
       
       const response = await request(app)
         .post('/callback')
         .send(callbackPayload)
         .expect(200);
       
       expect(response.body).toHaveProperty('received', true);
       // Verify message pushed to ElevenLabs
       // Verify task marked as completed
     });
   });
   ```

2. **Idempotency Tests**:
   ```typescript
   describe('Idempotency', () => {
     it('handles duplicate callbacks', async () => {
       // First callback
       await request(app).post('/callback').send({ requestId: 'task-123' });
       // Second callback (duplicate)
       const response = await request(app)
         .post('/callback')
         .send({ requestId: 'task-123' })
         .expect(200);
       
       expect(response.body).toHaveProperty('received', true);
     });
   });
   ```

3. **Missing Task Tests**:
   ```typescript
   describe('Missing Tasks', () => {
     it('handles missing callback task gracefully', async () => {
       const response = await request(app)
         .post('/callback')
         .send({ requestId: 'missing-task' })
         .expect(200);
       
       expect(response.body).toHaveProperty('received', true);
       // Verify logged but no error
     });
   });
   ```

4. **Message Format Tests**:
   ```typescript
   describe('Message Format', () => {
     it('constructs correct input_text message', async () => {
       // Verify message format matches ElevenLabs spec
     });
   });
   ```

## Inherent Risks

### High Risk
1. **Message Delivery Failures**:
   - **Risk**: Messages not delivered to ElevenLabs, breaking user experience
   - **Mitigation**: Retry logic, error handling, monitoring, fallback mechanisms

2. **Session Expiration**:
   - **Risk**: Session expired when callback arrives, causing delivery failure
   - **Mitigation**: Graceful error handling, clear logging, user notification

3. **WebSocket Push Failures**:
   - **Risk**: WebSocket connection issues preventing message delivery
   - **Mitigation**: Error handling, retry logic, HTTP fallback if available

### Medium Risk
4. **Message Format Errors**:
   - **Risk**: Incorrect message format causing ElevenLabs to reject
   - **Mitigation**: Format validation, tests, documentation review

5. **Race Conditions**:
   - **Risk**: Concurrent callbacks causing state corruption
   - **Mitigation**: Atomic operations, proper locking, idempotent design

### Low Risk
6. **Task State Update Failures**:
   - **Risk**: Task not marked as completed, affecting monitoring
   - **Mitigation**: Error handling, retry logic, monitoring

# Implement Network Failure Handling in Voice Service

## Scope
`jarek-va-ui`.

## Subtasks
- Use `retryWithBackoff` to implement reconnection with exponential backoff.
- Implement heartbeat messages and health checks at 30-second intervals.
- Add timeouts for initial connection and ongoing operations.
- Detect dropped audio, partial transcripts, and stuck speaking modes per plan.
- Add fallback logic for missing `onModeChange` events.
- Add automated tests (where feasible with mocks/fakes) that simulate failure modes and assert retries, state transitions, and user-facing error signals.

## Desired Outcomes

### Primary Outcomes
1. **Robust Reconnection**: Automatic reconnection with exponential backoff on network failures.

2. **Health Monitoring**: Heartbeat system detects connection issues and triggers recovery.

3. **Timeout Handling**: Proper timeouts prevent indefinite waiting on operations.

4. **Failure Detection**: Detection of various failure modes (dropped audio, stuck speaking, etc.).

5. **User Feedback**: Clear error messages and recovery indicators for users.

### Success Criteria
- Reconnection works with exponential backoff
- Heartbeat detects connection issues
- Timeouts prevent hanging operations
- Dropped audio detected and handled
- Partial transcripts handled correctly
- Stuck speaking mode detected and recovered
- Missing onModeChange events handled
- Tests cover all failure modes
- User-friendly error messages

## User Stories

### As a User
- **Story 1**: I want automatic reconnection so that network issues don't permanently break my voice session.
- **Story 2**: I want to know when reconnection is happening so that I understand any interruptions.

### As a Developer
- **Story 3**: I want robust failure handling so that the voice service is reliable.

## Suggested Automated Tests

### Unit Tests
1. **Reconnection Tests**:
   ```typescript
   describe('Network Failure Handling', () => {
     it('reconnects with exponential backoff', async () => {
       const service = new ElevenLabsVoiceService();
       // Simulate connection failure
       // Verify retry with backoff
     });
   });
   ```

2. **Heartbeat Tests**:
   ```typescript
   describe('Heartbeat', () => {
     it('detects connection failures', async () => {
       // Simulate heartbeat failure
       // Verify reconnection triggered
     });
   });
   ```

3. **Timeout Tests**:
   ```typescript
   describe('Timeouts', () => {
     it('times out initial connection', async () => {
       // Test connection timeout
     });
   });
   ```

4. **Failure Detection Tests**:
   ```typescript
   describe('Failure Detection', () => {
     it('detects dropped audio', async () => {
       // Test audio drop detection
     });
     
     it('detects stuck speaking mode', async () => {
       // Test stuck mode detection
     });
   });
   ```

## Inherent Risks

### High Risk
1. **Reconnection Loops**:
   - **Risk**: Infinite reconnection attempts causing performance issues
   - **Mitigation**: Max retry limits, exponential backoff, circuit breaker pattern

2. **False Positive Failures**:
   - **Risk**: Healthy connections detected as failed, causing unnecessary reconnections
   - **Mitigation**: Proper thresholds, multiple failure indicators, testing

### Medium Risk
3. **Heartbeat Performance**:
   - **Risk**: Heartbeat causing performance issues
   - **Mitigation**: Efficient heartbeat, appropriate intervals, monitoring

4. **Timeout Configuration**:
   - **Risk**: Timeouts too short or too long causing issues
   - **Mitigation**: Configurable timeouts, testing, monitoring

### Low Risk
5. **User Experience During Failures**:
   - **Risk**: Poor UX during failure recovery
   - **Mitigation**: Clear messaging, progress indicators, minimize disruption

# Implement MVP Cursor Completion â†’ Agent Push Flow

## Scope
`elevenlabs-agent`.

## Subtasks
- In the callback route, construct the MVP `input_text` message with a simple textual summary.
- Push the message to ElevenLabs using the stored `wsUrl` or equivalent.
- Log any errors without crashing the service.
- Confirm that the agent speaks/responds to the pushed completion message.
- Add tests that simulate callback payloads and assert that the correct message body would be sent to ElevenLabs (mocking the network layer).

## Desired Outcomes

### Primary Outcomes
1. **Completion Notifications**: When cursor tasks complete, agents receive notifications and can respond naturally.

2. **Message Delivery**: Completion messages successfully pushed to ElevenLabs agents via WebSocket.

3. **Error Resilience**: Push failures don't crash the service, with proper logging for debugging.

4. **Natural Conversation**: Agents respond to completion messages as if user typed them, maintaining conversation flow.

### Success Criteria
- Completion messages constructed correctly
- Messages pushed to ElevenLabs successfully
- Agent responds to completion messages
- Errors logged without crashing
- Tests verify message format
- Tests verify push logic
- End-to-end flow works

## User Stories

### As a User
- **Story 1**: I want to receive completion notifications so that I know when cursor tasks finish.
- **Story 2**: I want the agent to respond naturally so that the conversation flows smoothly.

### As a Developer
- **Story 3**: I want reliable message delivery so that users always get completion notifications.

## Suggested Automated Tests

### Unit Tests
1. **Message Construction Tests**:
   ```typescript
   describe('Message Construction', () => {
     it('constructs correct input_text message', () => {
       const callbackResult = {
         success: true,
         output: 'Task completed successfully'
       };
       
       const message = constructCompletionMessage(callbackResult);
       expect(message).toEqual({
         type: 'input_text',
         text: expect.stringContaining('Task completed')
       });
     });
   });
   ```

2. **Push Logic Tests**:
   ```typescript
   describe('Message Push', () => {
     it('pushes message to ElevenLabs', async () => {
       const mockPush = jest.fn();
       await pushToElevenLabs('wss://...', message);
       expect(mockPush).toHaveBeenCalledWith(message);
     });
   });
   ```

3. **Error Handling Tests**:
   ```typescript
   describe('Error Handling', () => {
     it('logs errors without crashing', async () => {
       const logSpy = jest.spyOn(console, 'error');
       // Simulate push failure
       expect(logSpy).toHaveBeenCalled();
       // Service should not crash
     });
   });
   ```

## Inherent Risks

### High Risk
1. **Message Delivery Failures**:
   - **Risk**: Messages not delivered, breaking user experience
   - **Mitigation**: Retry logic, error handling, monitoring, fallback

2. **WebSocket Connection Issues**:
   - **Risk**: WebSocket unavailable when callback arrives
   - **Mitigation**: Error handling, logging, user notification, session validation

### Medium Risk
3. **Message Format Errors**:
   - **Risk**: Incorrect message format causing ElevenLabs to reject
   - **Mitigation**: Format validation, tests, documentation review

4. **Session Expiration**:
   - **Risk**: Session expired when callback arrives
   - **Mitigation**: Session validation, graceful error handling, logging

### Low Risk
5. **Agent Response Quality**:
   - **Risk**: Agent doesn't respond well to completion messages
   - **Mitigation**: Message format optimization, agent prompt tuning, user feedback

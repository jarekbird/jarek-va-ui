# Introduce Agent Conversation Types in Frontend

## Scope
`jarek-va-ui`.

## Subtasks
- Create `src/types/agent-conversation.ts` with `AgentConversation` and `AgentMessage` interfaces from the plan.
- Ensure timestamps and IDs are treated as strings (or numbers) consistently and documented.
- Add any shared type aliases or enums for message `role` and `source` to avoid duplication.

## Desired Outcomes

### Primary Outcomes
1. **Type Safety**: Strong TypeScript types for agent conversations that prevent runtime errors and provide excellent IDE autocomplete support.

2. **Consistency**: Standardized data structures across the frontend for agent conversations, ensuring all components use the same types.

3. **Documentation**: Types serve as living documentation of the data structures, making it clear what fields are available and their expected formats.

4. **Reusability**: Shared enums and type aliases prevent duplication and ensure consistency across the codebase.

### Success Criteria
- All agent conversation types defined and exported
- Types match backend API contracts
- Enums used for `role` and `source` fields
- Timestamp and ID formats documented
- Types used consistently across components
- No `any` types in agent conversation code

## User Stories

### As a Developer
- **Story 1**: I want TypeScript types for agent conversations so that I get autocomplete and type checking when working with conversation data.
- **Story 2**: I want consistent types across the codebase so that I don't have to guess field names or formats.
- **Story 3**: I want enums for `role` and `source` so that I can't accidentally use invalid values.

### As a Code Reviewer
- **Story 4**: I want clear type definitions so that I can quickly understand the data structures being used.

## Suggested Automated Tests

### Type Tests
1. **Type Definition Tests**:
   ```typescript
   describe('AgentConversation Types', () => {
     it('AgentConversation has required fields', () => {
       const conversation: AgentConversation = {
         conversationId: 'test-id',
         messages: [],
         createdAt: '2024-01-01T00:00:00Z',
         lastAccessedAt: '2024-01-01T00:00:00Z'
       };
       expect(conversation).toBeDefined();
     });
     it('rejects invalid role values', () => {
       // TypeScript should error on invalid role
       // @ts-expect-error
       const message: AgentMessage = { role: 'invalid', ... };
     });
   });
   ```

2. **Enum Validation Tests**:
   ```typescript
   describe('MessageRole Enum', () => {
     it('contains expected values', () => {
       expect(MessageRole.USER).toBe('user');
       expect(MessageRole.AGENT).toBe('agent');
     });
     it('rejects invalid values', () => {
       // TypeScript compile-time check
     });
   });
   ```

### Type Compatibility Tests
3. **API Contract Alignment**:
   ```typescript
   describe('Type-API Alignment', () => {
     it('AgentConversation matches API response', async () => {
       const response = await fetch('/agent-conversations/api/123');
       const data: AgentConversation = await response.json();
       // TypeScript ensures structure matches
     });
   });
   ```

## Inherent Risks

### Medium Risk
1. **Type-API Mismatch**:
   - **Risk**: Frontend types don't match backend API, causing runtime errors
   - **Mitigation**: Validate types against actual API responses, use schema validation, update types when API changes

2. **Timestamp Format Inconsistency**:
   - **Risk**: Different timestamp formats (string vs Date) causing parsing errors
   - **Mitigation**: Document expected format (ISO 8601), use consistent parsing utilities, add validation

3. **ID Type Confusion**:
   - **Risk**: Mixing string and number IDs causing comparison bugs
   - **Mitigation**: Standardize on one type (prefer string), document decision, use type aliases

### Low Risk
4. **Enum Duplication**:
   - **Risk**: Same enum defined in multiple places, causing maintenance issues
   - **Mitigation**: Centralize enums in types file, export from single location, use barrel exports

5. **Overly Strict Types**:
   - **Risk**: Types too restrictive, preventing valid use cases
   - **Mitigation**: Use union types where appropriate, allow optional fields, review with team

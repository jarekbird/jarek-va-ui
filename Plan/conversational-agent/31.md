# Implement Text Message Flow for Agent Conversations

## Scope
`jarek-va-ui`, `elevenlabs-agent` (if needed).

## Subtasks
- Decide how text messages are sent (direct to ElevenLabs vs. through backend).
- Implement a simple text-based interaction path in `AgentConversationDetails.tsx`.
- Store text messages in `elevenlabs:conversation:{conversationId}` via backend (if not already present).
- Ensure the UI renders mixed voice and text messages consistently.

## Desired Outcomes

### Primary Outcomes
1. **Text Input Support**: Users can send text messages to agents in addition to voice, providing flexibility in communication.

2. **Unified Message History**: Voice and text messages appear together in conversation history with consistent formatting.

3. **Message Persistence**: Text messages stored in backend for conversation history and future reference.

4. **Consistent UX**: Text and voice messages rendered consistently with clear indicators of message source.

### Success Criteria
- Text input functional in agent conversations
- Text messages sent successfully
- Messages stored in backend
- Voice and text messages render consistently
- Message source indicators visible
- Tests cover text message flow
- Tests cover mixed message rendering

## User Stories

### As a User
- **Story 1**: I want to send text messages so that I can communicate when voice isn't convenient.
- **Story 2**: I want to see all messages (voice and text) together so that I have complete conversation history.

### As a Developer
- **Story 3**: I want consistent message rendering so that the UI is clean and predictable.

## Suggested Automated Tests

### Component Tests
1. **Text Input Tests**:
   ```typescript
   describe('Text Message Input', () => {
     it('sends text message', async () => {
       render(<AgentConversationDetails conversation={mockConv} />);
       const input = screen.getByPlaceholderText(/type a message/i);
       fireEvent.change(input, { target: { value: 'Hello agent' } });
       fireEvent.click(screen.getByText('Send'));
       
       await waitFor(() => {
         expect(mockSendMessage).toHaveBeenCalledWith('Hello agent');
       });
     });
   });
   ```

2. **Message Rendering Tests**:
   ```typescript
   describe('Message Rendering', () => {
     it('renders voice and text messages consistently', () => {
       const messages = [
         { role: 'user', content: 'Hello', source: 'voice' },
         { role: 'agent', content: 'Hi there', source: 'voice' },
         { role: 'user', content: 'How are you?', source: 'text' }
       ];
       
       render(<AgentConversationDetails messages={messages} />);
       // Verify all messages render with consistent styling
     });
   });
   ```

## Inherent Risks

### Medium Risk
1. **Message Source Confusion**:
   - **Risk**: Users can't distinguish voice vs text messages
   - **Mitigation**: Clear source indicators, visual differentiation, user testing

2. **Message Delivery Failures**:
   - **Risk**: Text messages not delivered or stored
   - **Mitigation**: Error handling, retry logic, user feedback

### Low Risk
3. **Rendering Performance**:
   - **Risk**: Large message lists causing performance issues
   - **Mitigation**: Virtual scrolling, pagination, performance testing

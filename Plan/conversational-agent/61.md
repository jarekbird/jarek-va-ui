# Step 61: Add Tests for Backend Service

**Phase**: Phase 4 – Polish, Error Handling, Testing, Documentation

## Description

Add tests for backend `elevenlabs-agent`:
- Session registration route behavior (valid/invalid payload).
- Callback queue logic (task creation, retrieval, completion).
- Webhook flow for a happy-path cursor tool (using a mocked `cursor-client`).

## Detailed Desired Outcomes

### Test Coverage

**Session Registration:**
- Test valid payload → success
- Test invalid payload → 400 error
- Test missing fields → 400 error
- Test session storage in Redis
- Test TTL setting
- Test error handling

**Callback Queue:**
- Test task creation
- Test task retrieval
- Test task completion
- Test task expiration
- Test Redis operations

**Webhook Flow:**
- Test valid webhook → success
- Test invalid auth → 401 error
- Test tool routing
- Test task creation
- Test cursor client call
- Test immediate response

**Integration:**
- Test complete flow: webhook → cursor → callback
- Test error scenarios
- Test edge cases

## User Stories

**As a developer**, I want:
- Comprehensive backend tests
- Tests that catch regressions
- Easy to run tests
- Good test coverage

**As a tester**, I want:
- Tests that cover all scenarios
- Tests that are easy to understand
- Fast-running tests

**As a system**, I want:
- Reliable backend service
- Tests that verify correctness
- No regressions

## Suggested Automated Tests

### Session Registration Tests

```typescript
describe('Session Registration', () => {
  it('should register session with valid payload', async () => {
    const payload = {
      sessionUrl: 'wss://...',
      sessionPayload: { config: { wsUrl: 'wss://...' } }
    };

    const response = await request(app)
      .post('/agent-conversations/api/conv-123/session')
      .send(payload);

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
  });

  it('should reject invalid payload', async () => {
    const response = await request(app)
      .post('/agent-conversations/api/conv-123/session')
      .send({}); // Missing required fields

    expect(response.status).toBe(400);
  });
});
```

### Callback Queue Tests

```typescript
describe('Callback Queue', () => {
  it('should save and retrieve task', async () => {
    const taskRecord: CursorTaskRecord = { /* ... */ };
    await saveTask('task-123', taskRecord);

    const retrieved = await getTask('task-123');
    expect(retrieved).toEqual(taskRecord);
  });

  it('should mark task as complete', async () => {
    await saveTask('task-123', taskRecord);
    await markTaskComplete('task-123');

    const task = await getTask('task-123');
    expect(task?.pending).toBe(false);
  });
});
```

### Webhook Flow Tests

```typescript
describe('Webhook Flow', () => {
  it('should handle cursor tool call', async () => {
    jest.spyOn(cursorClient, 'iterateAsync').mockResolvedValue({
      success: true,
      requestId: 'req-123'
    });

    const response = await request(app)
      .post('/agent-tools')
      .set('x-webhook-secret', 'test-secret')
      .send({
        tool: 'cursor_execute',
        args: { prompt: 'test' },
        conversation_id: 'conv-123'
      });

    expect(response.status).toBe(200);
    expect(cursorClient.iterateAsync).toHaveBeenCalled();
  });
});
```

## Risks

### Low Risk
- **Test complexity**: Tests might be complex
  - **Mitigation**: Keep tests simple, use good test utilities
  - **Detection**: Test maintenance

- **Mock accuracy**: Mocks might not match real behavior
  - **Mitigation**: Test with real services when possible
  - **Detection**: Integration tests

### Medium Risk
- **Test maintenance**: Tests might break frequently
  - **Mitigation**: Write stable tests
  - **Detection**: Test failures

### High Risk
- **None identified** - Backend testing with low risk

## Implementation Notes

- Test session registration endpoint
- Test with valid and invalid payloads
- Test callback queue operations
- Test webhook endpoint
- Mock cursor-client
- Test error cases
- Test Redis operations
- Use Jest or similar testing framework
- Test complete flows
- Aim for good coverage

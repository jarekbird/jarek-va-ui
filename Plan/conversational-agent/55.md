# Step 55: Add Loading and Error States

**Phase**: Phase 3 â€“ Frontend Integration (UI, Conversations, File Browser)

## Description

Add simple loading/error states for:
- Agent conversation list and details fetch.
- Repository file browser.
- Voice service connect/disconnect actions.

## Detailed Desired Outcomes

### Loading States

**Conversation List:**
- Show spinner or skeleton while fetching
- Message: "Loading conversations..."
- Don't show empty list while loading

**Conversation Details:**
- Show spinner while fetching conversation
- Message: "Loading conversation..."
- Don't show empty conversation while loading

**File Browser:**
- Show spinner while fetching file tree
- Message: "Loading files..."
- Don't show empty browser while loading

**Voice Service:**
- Show loading state while connecting
- Disable buttons during connection
- Message: "Connecting..." or spinner
- Show loading state while disconnecting

### Error States

**Conversation List Errors:**
- Show error message: "Failed to load conversations"
- Show retry button
- Don't show empty list (show error instead)

**Conversation Details Errors:**
- Show error message: "Failed to load conversation"
- Show retry button
- Show back navigation

**File Browser Errors:**
- Show error message: "Failed to load files"
- Show retry button (optional)
- Don't break conversation view

**Voice Service Errors:**
- Show error message for connection failures
- Show error for microphone permission denied
- Show manual reconnect option
- Don't crash the UI

### Consistent Styling

**Loading Indicators:**
- Use consistent spinner/skeleton component
- Consistent loading messages
- Consistent placement

**Error Messages:**
- Consistent error message format
- Consistent error styling
- Consistent retry buttons

## User Stories

**As a user**, I want:
- Clear feedback when things are loading
- Clear error messages when things fail
- Easy way to retry failed operations
- No confusing empty states

**As a developer**, I want:
- Reusable loading/error components
- Consistent patterns
- Easy to add to new components

**As a designer**, I want:
- Consistent loading/error UI
- Good user experience
- Clear visual feedback

## Suggested Automated Tests

### Loading State Tests

```typescript
describe('Loading States', () => {
  it('should show loading for conversation list', () => {
    jest.spyOn(api, 'listAgentConversations').mockImplementation(
      () => new Promise(() => {}) // Never resolves
    );

    render(<AgentConversationListView />);
    expect(screen.getByText(/Loading/i)).toBeInTheDocument();
  });

  it('should show loading for conversation details', () => {
    jest.spyOn(api, 'getAgentConversation').mockImplementation(
      () => new Promise(() => {})
    );

    render(<AgentConversationDetailView conversationId="test-123" />);
    expect(screen.getByText(/Loading/i)).toBeInTheDocument();
  });

  it('should show loading for file browser', () => {
    jest.spyOn(api, 'getRepositoryFileTree').mockImplementation(
      () => new Promise(() => {})
    );

    render(<ConversationDetails conversation={mockConversation} />);
    expect(screen.getByText(/Loading files/i)).toBeInTheDocument();
  });
});
```

### Error State Tests

```typescript
describe('Error States', () => {
  it('should show error for conversation list', async () => {
    jest.spyOn(api, 'listAgentConversations').mockRejectedValue(
      new Error('Network error')
    );

    render(<AgentConversationListView />);

    await waitFor(() => {
      expect(screen.getByText(/Failed to load/i)).toBeInTheDocument();
    });
  });

  it('should show retry button on error', async () => {
    jest.spyOn(api, 'listAgentConversations').mockRejectedValue(
      new Error('Network error')
    );

    render(<AgentConversationListView />);

    await waitFor(() => {
      expect(screen.getByRole('button', { name: /Retry/i })).toBeInTheDocument();
    });
  });

  it('should retry on button click', async () => {
    const listSpy = jest.spyOn(api, 'listAgentConversations')
      .mockRejectedValueOnce(new Error('Network error'))
      .mockResolvedValueOnce([]);

    render(<AgentConversationListView />);

    await waitFor(() => {
      const retryButton = screen.getByRole('button', { name: /Retry/i });
      fireEvent.click(retryButton);
    });

    expect(listSpy).toHaveBeenCalledTimes(2);
  });
});
```

## Risks

### Low Risk
- **Inconsistent states**: States might not be consistent across components
  - **Mitigation**: Use shared components, consistent patterns
  - **Detection**: Code review, visual testing

- **Missing error handling**: Some errors might not be handled
  - **Mitigation**: Comprehensive error handling, test error cases
  - **Detection**: Error testing, user reports

### Medium Risk
- **Poor error messages**: Error messages might not be helpful
  - **Mitigation**: Clear, actionable error messages
  - **Detection**: User testing, feedback

### High Risk
- **None identified** - Loading/error states with low risk

## Implementation Notes

- Add loading indicators for async operations
- Display error messages when operations fail
- Handle network errors gracefully
- Provide retry options where appropriate
- Show appropriate feedback to user
- Style loading/error states consistently
- Use shared loading/error components if available
- Test all error scenarios
- Make error messages actionable

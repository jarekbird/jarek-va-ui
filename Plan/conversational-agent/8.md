# Implement Repository File Browser Component

## Scope
`jarek-va-ui`.

## Subtasks
- Create `RepositoryFileBrowser.tsx` to render a read-only tree:
  - Collapsible directories.
  - File/folder icons.
  - Display full paths or tooltips for deep paths.
- Create an `api` helper for `/repositories/api/:repository/files`.
- Add the file browser to the note-taking detail view (or a dedicated tab) with clear "browse-only" messaging.
- Add minimal styling to fit existing layout (no UX regressions on smaller screens).

## Desired Outcomes

### Primary Outcomes
1. **Visual File Tree**: Interactive tree view that allows users to explore repository structure visually, with expand/collapse functionality.

2. **Clear Read-Only Indication**: Users understand this is browse-only, not an editor, preventing confusion about file modification capabilities.

3. **Responsive Design**: Component works well on all screen sizes, maintaining usability on mobile devices.

4. **Performance**: Efficient rendering of large file trees without UI lag or memory issues.

5. **Accessibility**: Keyboard navigation and screen reader support for inclusive access.

### Success Criteria
- Tree view renders correctly with proper nesting
- Directories can be expanded/collapsed
- File and folder icons displayed correctly
- Full paths visible (via tooltip or display)
- Read-only messaging clear and visible
- Responsive on mobile devices
- Keyboard navigation works
- Large trees render without performance issues
- Loading and error states handled

## User Stories

### As a User
- **Story 1**: I want to see the file structure of my repository so that I can understand the codebase organization.
- **Story 2**: I want to expand and collapse directories so that I can navigate large file trees easily.
- **Story 3**: I want to see full file paths so that I know exactly where files are located.
- **Story 4**: I want it clear that this is read-only so that I don't try to edit files here.

### As a Developer
- **Story 5**: I want a reusable file browser component so that I can use it in other parts of the app if needed.
- **Story 6**: I want the component to handle large trees efficiently so that performance doesn't degrade.

## Suggested Automated Tests

### Component Tests
1. **Rendering Tests**:
   ```typescript
   describe('RepositoryFileBrowser', () => {
     it('renders file tree structure', () => {
       const mockTree = { name: 'root', type: 'directory', children: [...] };
       render(<RepositoryFileBrowser tree={mockTree} />);
       expect(screen.getByText('root')).toBeInTheDocument();
     });
     
     it('shows file and folder icons', () => {
       // Verify icons render correctly
     });
     
     it('displays read-only message', () => {
       render(<RepositoryFileBrowser tree={mockTree} />);
       expect(screen.getByText(/read-only/i)).toBeInTheDocument();
     });
   });
   ```

2. **Interaction Tests**:
   ```typescript
   describe('Tree Interactions', () => {
     it('expands directory on click', () => {
       render(<RepositoryFileBrowser tree={mockTree} />);
       const dir = screen.getByText('src');
       fireEvent.click(dir);
       expect(screen.getByText('index.ts')).toBeInTheDocument();
     });
     
     it('collapses expanded directory', () => {
       // Test collapse functionality
     });
     
     it('shows tooltip with full path on hover', () => {
       // Test tooltip display
     });
   });
   ```

3. **API Integration Tests**:
   ```typescript
   describe('API Integration', () => {
     it('fetches file tree on mount', async () => {
       jest.spyOn(api, 'getRepositoryFiles').mockResolvedValue(mockTree);
       render(<RepositoryFileBrowser repositoryId="test-repo" />);
       await waitFor(() => {
         expect(api.getRepositoryFiles).toHaveBeenCalledWith('test-repo');
       });
     });
     
     it('handles loading state', () => {
       // Test loading indicator
     });
     
     it('handles error state', async () => {
       // Test error display
     });
   });
   ```

### Performance Tests
4. **Large Tree Tests**:
   ```typescript
   describe('Performance', () => {
     it('renders large trees without lag', () => {
       const largeTree = generateLargeTree(1000); // 1000 nodes
       const start = performance.now();
       render(<RepositoryFileBrowser tree={largeTree} />);
       const duration = performance.now() - start;
       expect(duration).toBeLessThan(100); // < 100ms
     });
   });
   ```

### Accessibility Tests
5. **Keyboard Navigation Tests**:
   ```typescript
   describe('Accessibility', () => {
     it('navigates tree with keyboard', () => {
       render(<RepositoryFileBrowser tree={mockTree} />);
       const firstItem = screen.getByRole('treeitem');
       firstItem.focus();
       fireEvent.keyDown(firstItem, { key: 'ArrowDown' });
       // Verify focus moves
     });
   });
   ```

## Inherent Risks

### High Risk
1. **Performance with Large Trees**:
   - **Risk**: UI becomes slow or unresponsive with repositories containing thousands of files
   - **Mitigation**: Virtual scrolling, lazy loading children, limit initial expansion, performance testing

2. **Memory Issues**:
   - **Risk**: Rendering entire tree in DOM causes memory problems
   - **Mitigation**: Virtual DOM, render only visible nodes, cleanup on unmount

### Medium Risk
3. **Mobile UX Issues**:
   - **Risk**: File browser difficult to use on small screens
   - **Mitigation**: Responsive design, touch-friendly interactions, mobile-specific UI patterns

4. **Accessibility Gaps**:
   - **Risk**: Component not usable with keyboard or screen readers
   - **Mitigation**: ARIA labels, keyboard navigation, screen reader testing

5. **State Management**:
   - **Risk**: Expanded/collapsed state lost on re-render or navigation
   - **Mitigation**: Persist state in URL or localStorage, proper state management

### Low Risk
6. **Styling Inconsistencies**:
   - **Risk**: Component doesn't match app design system
   - **Mitigation**: Use design system components, follow style guide, visual QA

7. **Tooltip Performance**:
   - **Risk**: Too many tooltips causing performance issues
   - **Mitigation**: Lazy tooltip rendering, debounce hover events, limit tooltip count

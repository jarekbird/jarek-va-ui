# Implement Retry Utility with Exponential Backoff

## Scope
`jarek-va-ui`.

## Subtasks
- Implement `src/utils/retry.ts` with `retryWithBackoff` and `RetryOptions` per plan.
- Support configurable `maxRetries`, delays, and callbacks for logging.
- Add unit tests to confirm timing and retry behavior.

## Desired Outcomes

### Primary Outcomes
1. **Retry Mechanism**: Reusable utility for retrying failed operations with exponential backoff.

2. **Configurability**: Flexible configuration for different retry scenarios.

3. **Logging Support**: Optional callbacks for logging retry attempts.

4. **Test Coverage**: Comprehensive tests verifying retry behavior and timing.

### Success Criteria
- Retry function works correctly
- Exponential backoff implemented (1s, 2s, 4s, 8s, 16s, max 30s)
- Max retries configurable (default 5)
- Callbacks for logging supported
- Tests verify timing
- Tests verify retry behavior
- Reusable across codebase

## User Stories

### As a Developer
- **Story 1**: I want a retry utility so that I can handle transient network failures.
- **Story 2**: I want configurable retries so that I can adjust behavior for different scenarios.

## Suggested Automated Tests

### Unit Tests
1. **Retry Behavior Tests**:
   ```typescript
   describe('retryWithBackoff', () => {
     it('retries on failure', async () => {
       let attempts = 0;
       const fn = async () => {
         attempts++;
         if (attempts < 3) throw new Error('Failed');
         return 'success';
       };
       
       const result = await retryWithBackoff(fn);
       expect(result).toBe('success');
       expect(attempts).toBe(3);
     });
     
     it('respects max retries', async () => {
       const fn = async () => { throw new Error('Failed'); };
       await expect(retryWithBackoff(fn, { maxRetries: 3 }))
         .rejects.toThrow();
     });
   });
   ```

2. **Timing Tests**:
   ```typescript
   describe('Exponential Backoff Timing', () => {
     it('delays increase exponentially', async () => {
       const delays: number[] = [];
       const fn = async () => { throw new Error('Failed'); };
       
       await retryWithBackoff(fn, {
         onRetry: (attempt, error) => {
           delays.push(Date.now());
         }
       }).catch(() => {});
       
       // Verify delays: ~1s, ~2s, ~4s, etc.
     });
   });
   ```

## Inherent Risks

### Medium Risk
1. **Timing Accuracy**:
   - **Risk**: Delays not accurate, causing performance issues
   - **Mitigation**: Use proper timing functions, test timing, consider jitter

2. **Infinite Retry Loops**:
   - **Risk**: Retries never stop on persistent failures
   - **Mitigation**: Max retries limit, timeout mechanisms, clear error handling

### Low Risk
3. **Performance Impact**:
   - **Risk**: Retries causing excessive delays
   - **Mitigation**: Configurable limits, timeout handling, monitoring
